import hmac
import hashlib
import logging
import requests
import time

try:
    from urllib import urlencode

# for python3
except ImportError:
    from urllib.parse import urlencode

ENDPOINT = "https://www.binance.com"

BUY = "BUY"
SELL = "SELL"

LIMIT = "LIMIT"
MARKET = "MARKET"

GTC = "GTC"
IOC = "IOC"

options = {}


def set(apiKey, secret):
    """Set API key and secret.
    Must be called before any making any signed API calls.
    """
    options["apiKey"] = apiKey
    options["secret"] = secret




def balances():
    """Get current balances for all symbols."""
    data = signedRequest("GET", "/api/v3/account", {})
    if 'msg' in data:
        raise ValueError("Error from exchange: {}".format(data['msg']))

    return {d["asset"]: {
        "free": d["free"],
        "locked": d["locked"],
    } for d in data.get("balances", [])}


def order(symbol, side, quantity, price, orderType=LIMIT, timeInForce=GTC,
          test=False, **kwargs):
    """Send in a new order.
    Args:
        symbol (str)
        side (str): BUY or SELL.
        quantity (float, str or decimal)
        price (float, str or decimal)
        orderType (str, optional): LIMIT or MARKET.
        timeInForce (str, optional): GTC or IOC.
        test (bool, optional): Creates and validates a new order but does not
            send it into the matching engine. Returns an empty dict if
            successful.
        newClientOrderId (str, optional): A unique id for the order.
            Automatically generated if not sent.
        stopPrice (float, str or decimal, optional): Used with stop orders.
        icebergQty (float, str or decimal, optional): Used with iceberg orders.
    """
    params = {
        "symbol": symbol,
        "side": side,
        "type": orderType,
        "timeInForce": timeInForce,
        "quantity": formatNumber(quantity),
        "price": formatNumber(price),
    }
    params.update(kwargs)
    path = "/api/v3/order/test" if test else "/api/v3/order"
    data = signedRequest("POST", path, params)
    return data


def orderStatus(symbol, **kwargs):
    """Check an order's status.
    Args:
        symbol (str)
        orderId (int, optional)
        origClientOrderId (str, optional)
        recvWindow (int, optional)
    """
    params = {"symbol": symbol}
    params.update(kwargs)
    data = signedRequest("GET", "/api/v3/order", params)
    return data


def cancel(symbol, **kwargs):
    """Cancel an active order.
    Args:
        symbol (str)
        orderId (int, optional)
        origClientOrderId (str, optional)
        newClientOrderId (str, optional): Used to uniquely identify this
            cancel. Automatically generated by default.
        recvWindow (int, optional)
    """
    params = {"symbol": symbol}
    params.update(kwargs)
    data = signedRequest("DELETE", "/api/v3/order", params)
    return data


def openOrders(symbol, **kwargs):
    """Get all open orders on a symbol.
    Args:
        symbol (str)
        recvWindow (int, optional)
    """
    params = {"symbol": symbol}
    params.update(kwargs)
    data = signedRequest("GET", "/api/v3/openOrders", params)
    return data


def allOrders(symbol, **kwargs):
    """Get all account orders; active, canceled, or filled.
    If orderId is set, it will get orders >= that orderId. Otherwise most
    recent orders are returned.
    Args:
        symbol (str)
        orderId (int, optional)
        limit (int, optional): Default 500; max 500.
        recvWindow (int, optional)
    """
    params = {"symbol": symbol}
    params.update(kwargs)
    data = signedRequest("GET", "/api/v3/allOrders", params)
    return data


def myTrades(symbol, **kwargs):
    """Get trades for a specific account and symbol.
    Args:
        symbol (str)
        limit (int, optional): Default 500; max 500.
        fromId (int, optional): TradeId to fetch from. Default gets most recent
            trades.
        recvWindow (int, optional)
    """
    params = {"symbol": symbol}
    params.update(kwargs)
    data = signedRequest("GET", "/api/v3/myTrades", params)
    return data


def request(method, path, params=None):
    resp = requests.request(method, ENDPOINT + path, params=params)
    data = resp.json()
    if "msg" in data:
        logging.error(data['msg'])
    return data


def signedRequest(method, path, params):
    if "apiKey" not in options or "secret" not in options:
        raise ValueError("Api key and secret must be set")

    query = urlencode(sorted(params.items()))
    query += "&timestamp={}".format(int(time()))
    secret = bytes(options["secret"].encode("utf-8"))
    signature = hmac.new(secret, query.encode("utf-8"),
                         hashlib.sha256).hexdigest()
    query += "&signature={}".format(signature)
    resp = requests.request(method,
                            ENDPOINT + path + "?" + query,
                            headers={"X-MBX-APIKEY": options["apiKey"]})
    data = resp.json()
    if "msg" in data:
        logging.error(data['msg'])
    return data
